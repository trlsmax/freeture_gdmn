#!/bin/sh
if [ true != "${INIT_D_SCRIPT_SOURCED}" ] ; then
    echo "sourcing /lib/init/init-d-script"
    set "$0" "$@"; INIT_D_SCRIPT_SOURCED=true . /lib/init/init-d-script
fi
### BEGIN INIT INFO
# Provides:          freeture
# Required-Start:    $remote_fs $syslog $ntp
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Freeture init script
# Description:       This file is used to daemonised freeture application.
#                    Should be placed in /etc/init.d
#                    Start a single forking daemon capable of writing a pid
#                    file.
# Author: Adrien Malgoyre <adrien.malgoyre@osupytheas.fr>
### END INIT INFO 

#set -e"

# The daemon will be run as this user
 #USER="dfn-operator"
 #GROUP="dfn-user"
## need to be root to have write access to the data directories
USER="root"
GROUP="root"
HOME=$(grep "^${USER}:" /etc/passwd | cut -d: -f6)
FUID=$(id -u ${USER})
GID=$(id -g ${GROUP})

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=/usr/local/bin/freeture
DEAMON_CFG="/usr/local/etc/dfn/freeture.cfg"
NAME=freeture
PIDDIR="/var/run/${NAME}"
PIDFILE="${PIDDIR}/${NAME}.pid"
SCRIPTNAME=/etc/init.d/${NAME}
DESC="FreeTure Daemon"
DAEMON_ARGS="-m 3 -c ${DEAMON_CFG}"

# create pid directory if it does not exist
[ -d ${PIDDIR} ] || mkdir -p ${PIDDIR}

# Exit if the package is not installed
[ -x "${DAEMON}" ] || exit 0

# Read configuration variable file if it is present
#[ -r ${DEAMON_CFG} ] && . ${DEAMON_CFG}

#
# freeture preconfig
#
# - the actual config file is generated by a script
# /opt/dfn-software/freeture_preconfig.py
#
FREETURE_LOG_DIR="/data0/log/freeture"
FREETURE_PRECONFIG_LOG_DIR=${FREETURE_LOG_DIR}/preconfig
[ -d ${FREETURE_PRECONFIG_LOG_DIR} ] || mkdir -p ${FREETURE_PRECONFIG_LOG_DIR} 
FREETURE_PRECONFIG_LOG=${FREETURE_PRECONFIG_LOG_DIR}/freeture_preconfig_$(date -u "+%Y-%m-%d_%H%M%S")UTC.log

VERBOSE=YES

preconfig()
{
    echo ""
    echo "Generating config file..."
    python3 /opt/dfn-software/freeture_preconfig.py > ${FREETURE_PRECONFIG_LOG} 2>&1
    preconfig_result=${?}
    # preconfig_result  is  0 if no python err, otherwise non-zero
    cat ${FREETURE_PRECONFIG_LOG}
    if [ ${preconfig_result} -eq 0 ]
    then
	# modification of freeture config succeeded, let's use this one
	freetureconf=$(tail -n 1 ${FREETURE_PRECONFIG_LOG})
	DAEMON_ARGS="-m 3 -c ${freetureconf}"
	echo "Generating config file OK"
	# dump it as default for future, if something went wrong
	cp ${freetureconf} ${DEAMON_CFG}
    else
	# running of python3 /opt/dfn-software/freeture_preconfig.py failed
	# perhaps some internal interval_control_sw incompatibility
	# let's go with default ${DEAMON_CFG}
	echo "Generating config file FAILED, using default ${DEAMON_CFG}"
    fi
    echo "manual start would be ${DAEMON} ${DAEMON_ARGS}"
}

#
# Function that starts the daemon/service
#
do_start()
{
	export USER HOME
        # Return
        #   0 if daemon has been started
        #   1 if daemon was already running
        #   2 if daemon could not be started
        #start-stop-daemon --start --user ${USER} --make-pidfile --pidfile ${PIDFILE} --exec ${DAEMON} --test > /dev/null
	#RETVAL=$?
	#if [ "$RETVAL" = 1 ]
	if [ -e ${PIDFILE} ]
	then
	    ps -aux | grep ${DAEMON} | grep $(cat ${PIDFILE}) 
	    RETVAL=$?
	    echo "RETVAL=$RETVAL"
	    if [ "$RETVAL" = 1 ]
	    then
		echo "${PIDFILE} exists, but no daemon ${DAEMON} with pid $(cat ${PIDFILE}) is running."
		echo "Remove pidfile and start service ${NAME}"
		rm -rf ${PIDFILE}
		#do_stop
	    else
		echo "${PIDFILE} exists and daemon ${DAEMON} with pid $(cat ${PIDFILE}) is running, quitting."
		return 1
	    fi
	fi
	preconfig
        start-stop-daemon --chuid ${FUID}:${GID} --user ${USER} --start --quiet --background --make-pidfile --pidfile ${PIDFILE} --exec ${DAEMON} -- ${DAEMON_ARGS} > /dev/null \
                || return 2
        # Add code here, if necessary, that waits for the process to be ready
        # to handle requests from services started subsequently which depend
        # on this one.  As a last resort, sleep for some time.
}

#
# Function that stops the daemon/service
#
do_stop()
{
        # Return
        #   0 if daemon has been stopped
        #   1 if daemon was already stopped
        #   2 if daemon could not be stopped
        #   other if a failure occurred
        start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile ${PIDFILE} --name ${NAME}
        RETVAL="$?"
        [ "${RETVAL}" = 2 ] && return 2
        # Wait for children to finish too if this is a daemon that forks
        # and if the daemon is only ever run from this initscript.
        # If the above conditions are not satisfied then add some other code
        # that waits for the process to drop all resources that could be
        # needed by services started subsequently.  A last resort is to
        # sleep for some time.
        start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec ${DAEMON}
        [ "$?" = 2 ] && return 2
        # Many daemons don't delete their pidfiles when they exit.
        rm -f ${PIDFILE}
        return "${RETVAL}"
}

case "$1" in
  start)
	[ "${VERBOSE}" != no ] && log_daemon_msg "Starting ${DESC}" "${NAME}"
        do_start
	case "$?" in
                0|1) [ "${VERBOSE}" != no ] && log_end_msg 0 ;;
                2) [ "${VERBOSE}" != no ] && log_end_msg 1 ;;
        esac

        ;;
  stop)
        [ "${VERBOSE}" != no ] && log_daemon_msg "Stopping ${DESC}" "${NAME}"
        do_stop
        case "$?" in
                0|1) [ "${VERBOSE}" != no ] && log_end_msg 0 ;;
                2) [ "${VERBOSE}" != no ] && log_end_msg 1 ;;
        esac
        ;;
  status)
        status_of_proc "${DAEMON}" "${NAME}" && exit 0 || exit $?
        ;;
  restart)
      echo "case restart"
        do_stop
        do_start
        ;;
  *)
        echo "Usage: ${SCRIPTNAME} {start|stop|status|restart}" >&2
        exit 3
        ;;
esac
